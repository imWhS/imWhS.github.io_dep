{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/16/hello-world/"},{"title":"Swift 흐름 제어 구문","text":"변수 및 상수 등의 선언문, 연산자를 이용한 처리문, 함수 및 구조체 정의문 등의 단순 구문과 달리, 흐름 제어 구문은 반복문, 조건문, 제어 전달문 등과 같이 코드를 읽는 흐름의 방향을 변경하는 역할을 한다. for123for 루프 상수 in 순회 대상 { 반복 실행할 구문} 루프 상수: for을 이용해 구문이 반복될 때마다 순회 대상이 가지는 아이템들을 하나 씩 새로 넘겨 받아 구문 내에서 순회 대상 개별 아이템을 대표하는 상수를 선언하는 영역이다. 매 번 자동으로 상수로 재선언되기 때문에 let 키워드를 코드에 포함시킬 필요는 없다. 순회 대상: 구문이 반복될 때마다 루프 상수에 전달될 아이템들을 가지는 데이터로, 해당 데이터의 타입이 포함하고 있는 아이템 개수만큼 구문이 반복된다. 순회 대상으로 쓸 수 있는 타입: 배열, 딕셔너리, 집합, 범위 연산자 데이터, 문자열 등 1234var str = &quot;Hello world&quot;for char in str.characters { print(&quot;str이 포함하는 개별 char: \\(char)&quot;)} String 문자열 타입의 데이터를 순회 대상으로 사용할 경우 String의 characters 속성을 사용해 char 루프 상수로 Character 타입으로 넘겨주어야 한다. String 자체는 순회 처리를 지원하지 않기 때문이다. 루프 상수가 굳이 필요하지 않다면 생략의 의미로 _로 대체할 수도 있다. while123while 조건문 { 반복 실행할 구문} repeat~while1234repeat { 반복 실행할 구문(단, 반드시 최소 한 번은 실행할 구문)}while 조건문 if~else/else if1234567if 조건문 A { 조건문 A가 참일 때 실행할 구문} else if 조건문B { //필요한 경우 조건문 B가 참일 때 실행할 구문} else { //필요한 경우 앞 if 조건문들이 모두 거짓일 때 실행할 구문} guard~else1234guard 조건문 else { 조건문이 거짓일 때 실행할 구문 return 혹은 break 조기 종료 구문} 다음 코드들이 실행되기 전, 특정한 조건을 만족하지 않아 오류를 발생하는 경우를 방지하기 위해 사용하기 때문에 조건식이 false일 때에만 내부 구문이 실행된다. 그래서 반드시 블록 내부에 (특정한 조건을 만족하지 않아 다음 코드를 실행하지 못하게 조기 종료 시키는) return이나 break 구문이 포함되어야 한다. 함수/메서드에서 주로 사용된다. switch12345678switch 비교 대상 { case 비교 패턴 A: 비교 대상의 값이 비교 패턴 A와 같은 경우 실행할 구문 case 비교 패턴 B: 비교 대상의 값이 비교 패턴 B와 같은 경우 실행할 구문 default: 비교 대상의 값이 비교 패턴 A, 패턴 B 모두 해당하지 않을 경우 실행할 구문} 기존 C언어, Java와 달리, 비교 패턴 A나 패턴 B와 일치해 해당 구문을 실행한 경우 이 외/아래 라인에 위치한 case 구문은 실행하지 않는다. 패턴 A, 패턴 B 모두 일치하더라도 더 상위 라인에 위치한 패턴 A에 대한 case 구문만 실행한 후 패턴 B에 대한 case 구문은 실행하지 않는다. 즉, 기존 대부분 언어의 switch 문과 달리 각 case 블록에 break 구문을 굳이 포함시킬 필요가 없다. Swift의 경우 반드시 switch 내 하나의 블록이라도 실행되어야 한다. 물론 단 하나의 비교 패턴과도 일치하지 않을 수도 있기 때문에, 이 경우를 대비해 default 구문을 추가한다. fallthroughSwift는 각 case 블록을 비워두어선 안 되며, 특히 암시적 fallthrough를 지원하지 않는다. 그래서 처음 일치한 case 구문이 아닌, 다음 라인(이후)의 case 구문을 실행하고자 한다면 fallthrough 구문을 명시해야 한다. 암시적 fallthrough: 다른 언어의 경우 break 구문이 없다면 처음 비교 패턴이 일치한 case 구문부터 마지막 default까지 모두 실행된다. 튜플을 이용한 활용123456789101112var tup = (2, 3)switch tup { case let (x, 3): print(&quot;tup의 두 번째 값 3과 일치합니다. 이 때 첫 번째 값은 \\(x)입니다.&quot;); //실제 콘솔 출력: tup의 두 번째 값 3과 일치합니다. 이 때 첫 번째 값은 2입니다. case let (2, y): print(&quot;tup의 첫 번째 값 2와 일치합니다. 이 때 두 번째 값은 \\(y)입니다.&quot;); //실제 콘솔 출력: tup의 첫 번째 값 2와 일치합니다. 이 때 두 번째 값은 3입니다. case let (x, y): print(&quot;tup의 첫 번째 값은 \\(x), 두 번째 값은 \\(y)입니다.&quot;); //실제 콘솔 출력: tup의 첫 번째 값은 2, 두 번째 값은 3입니다.} 비교 대상으로 튜플을 사용할 경우, 비교 패턴의 튜플과 ‘일부 패턴’만 일치하더라도 같다고 판단해 해당 case 구문을 실행한다. where을 이용한 활용123456789var couple = (3, -3)switch couple { case let (x, y) where x == y: print(&quot;\\(x), \\(y)의 값이 같습니다.&quot;) case let (x, y) where x == -y: print(&quot;\\(x), \\(y) 서로 절대값만 같습니다.&quot;) case let (x, y): print(&quot;\\(x), \\(y) 서로 값이 다릅니다.&quot;);} switch 문에서 임시로 사용되는 x, y 값에 대한 조건을 where 구문으로 추가할 수 있다. Reference 꼼꼼한 재은 씨의 스위프트(Swift): 문법편","link":"/2020/11/17/Swift-%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4-%EA%B5%AC%EB%AC%B8/"},{"title":"운영체제 개요 : What Operating Systems Do","text":"운영체제란운영체제는 소프트웨어입니다. 운영체제는 컴퓨터 시스템을 구성하는 하드웨어(CPU, 저장 장치 등)의 바로 윗 계층에 위치해있고, 특히 이 하드웨어를 직접적으로, 가장 가까운 위치에서 동작시킬 수 있기 때문에 시스템 소프트웨어로 분류합니다. 아쉽게도 하드웨어 자체만으로는 사용자의 입장에서 도움 되는 기능(리그 오브 레전드 실행, 넷플릭스 영상 재생 등)을 단 하나도 제공받을 수 없습니다. KFC에 생닭, 밀가루랑 튀김기가 있어도 알바가 없으면 핫크리스피 치킨을 못 만들듯이 여러 하드웨어들 간 서로 유기적으로 동작시키는 주체가 없으면 이들은 그저 공간만 차지하는 고철 덩어리에 불과합니다. 사실상 일반적으로 우리가 컴퓨터에서 돌린다고 말하는 소프트웨어들은 컴퓨터 시스템을 구성하는 하드웨어 뿐 아니라, 운영체제를 포함한 계층 위에서 실행된다고 보는 게 맞습니다. 최근, 사용자 편의를 위해 운영체제가 부가적으로 제공하는 기능들이 점점 많아지고 있습니다. 운영체제도 결국 소프트웨어이기 때문에 메모리에 적재되어야 하는데, 이 부가적인 요소까지 적재하기에는 메모리 공간이 그렇게 여유롭지 못합니다. 그래서 운영체제를 구성하는 요소 중에서도 정말 핵심적인(아래에서 설명할) 것들은 **커널(모듈)**로 따로 묶여지고, 컴퓨터가 가동되는 중에는 이들만 항상 메모리에 상주하게 됩니다. 운영체제의 역할운영체제는 시스템 소프트웨어로서, 하드웨어와 응용 소프트웨어(애플리케이션, 사용자 프로그램) 사이에서 매개 역할을 합니다. 애플리케이션을 구성하는 코드를 읽을 수 있는 CPU 자원은 컴퓨터 시스템에서 단 1개 뿐입니다(싱글 프로세서 시스템 기준). 컴퓨터 시스템 입장에서는 운영체제가 자신을 제어하면서 하드웨어 자원을 필요로 하는 수 많은 애플리케이션들이 서로 싸우지 않고 협력적으로 작동할 수 있도록 자원을 공평하게 분배해줍니다. PC 혹은 스마트폰 등을 직접적으로 사용하는 입장에서는, 그저 터치스크린이나 키보드 마우스만으로 컴퓨터 시스템을 작동시킬 수 있다는 것을 너무나 잘 알고 있습니다. 컴퓨터 시스템을 구성하는 자원이 무엇이고, 서로 어떻게 동작하는지는 전혀 알 바 아닌 것 또한 잘 알고 있습니다. 운영체제가 바로 아래 계층인 하드웨어 단을 사용자에게 추상화시켜준 덕분에, 사용자가 보다 컴퓨터를 쉽게 사용할 수 있게 됩니다. 많이들 알고 계시듯이, 운영체제 계층에서 GUI를 제공해주기에 사용자는 마우스나 터치스크린 입력 등을 통해 사용자가 보다 더 편리하게 컴퓨터 시스템을 다룰 수 있습니다. 특히, 최근에는 다중 사용자를 지원하는 운영체제가 대부분입니다. 한 대의 컴퓨터만으로 여러 명의 사람들이 각자 원하는 프로그램을 실행할 수 있게 지원하는 기능으로, 운영체제는 각 사용자 입장에서 컴퓨터를 자신만 사용하고 있다고 느낄 수 있도록 추상화시켜줍니다. 뿐만 아니라 여러 사용자들 또한 컴퓨터가 제공하는 하드웨어 자원을 공평하게 사용할 수 있도록 운영체제가 분배합니다. 하나의 컴퓨터에서 여러 소프트웨어가 동시에 돌아가고, 여러 사용자가 동시에 사용하다보면 서로 다른 소프트웨어 혹은 사용자 간 악의적인 접근과 같은 보안 문제가 발생할 수 있습니다. 우리의 운영체제는 이에 대해서도 보호 기능을 제공함으로써 보다 편리하고 효율적으로 컴퓨터 시스템을 사용할 수 있도록 도와줍니다. 운영체제의 주요 기능을 아래와 같이 정리할 수 있겠습니다. 시스템 관점 컴퓨터 시스템 자원(CPU, 메모리 등)에서 발생하는 문제 해결, 제어 컴퓨터 시스템 자원을 여러 프로그램에게 균형있게 분배 프로그램을 악의적인 애플리케이션으로부터 보호/ 사용자 관점 사용자가 컴퓨터를 보다 편리하게 사용할 수 있는 환경 제공 컴퓨터 시스템 자원을 여러 사용자에게 균형있게 분배 사용자 개인 정보를 악의적인 애플리케이션으로부터 보호 운영체제의 분류 기준과 종류동시 작업 지원 여부에 따른 분류사실 아주 예전에는 사용자를 기준으로 특정 시점에서 하나의 프로그램만 실행할 수 있었습니다. 그 때까지는 하나의 CPU가 달린 컴퓨터라면 당연히 하나의 프로그램만 실행할 수 있어야 했다고 생각했었을까요..? 아무튼 이 때와 같은 운영체제는 프로그램 단 하나로만 작업할 수 있다는 의미 그대로 싱글태스킹(단일 작업, Singletasking) 운영체제라고 부릅니다. 하지만 똑똑한 분들께서 기가 막힌 아이디어를 내놓게 됩니다. ‘사용자는 절대 눈치챌 수 없게 CPU가 작업하는 시간을 겁나 짧은 단위 시간으로 나눠서, 각 단위 시간을 여러 프로그램들이 나누어 쓰게 하면 결국 겁나 짧은 단위 시간까지 인지 못하는 사용자의 눈에는 여러 프로그램이 하나의 컴퓨터에서 동시에 돌아가는 것처럼 보이지 않을까?’ 이 글을 보고 계신 지금도 ‘겁나 짧은 단위 시간’을 모니터에서 못 느끼고 계시죠? 이 기가 막힌 아이디어를 시분할(timesharing) 기법이라는 직관적인 이름으로 부르고, 이 기법을 쓰는 컴퓨터 시스템(시분할 시스템)에서는 보통 ms 이내의 규모로 여러 프로그램들의 전환이 운영체제에 의해 발생합니다. 시분할 시스템은 사용자 편의성 측면에서도 이득입니다. 시분할 기법을 사용하는 시스템을 **대화형 시스템(Interactive system, 쌍방향 시스템)**이라고도 부르는데요. 여러 프로그램을 동시에 실행시켜도 사용자 입장에서는 마구잡이로 아무 프로그램에 던진 입력에 대한 결과(출력)를 다른 사람과 대화하듯이 즉각적으로 받을 수 있기 때문입니다. 즉, 시분할 기법을 채용해 대화형 시스템을 구현하면 컴퓨터 시스템의 **응답 시간(Response time)**이 단축되고, 컴퓨터를 자신이 혼자서 독차지하고 있다고 느끼게 할 수 있습니다. 이에 따라 생산성과 효율성이 향상됩니다. 시분할 기법을 쓰는 시스템이 생긴 덕분에, 지금의 멀티태스킹(다중 작업, Multi-tasking) 운영체제가 탄생합니다. 즉, 사용자가 모니터를 보는 시점 기준으로 2개 이상의 프로그램을 동시에 실행할 수 있게 됩니다. 한 시점에서 여러 프로그램을 실행할 수 있는지 여부에 따라 운영체제를 아래와 같이 분류할 수 있겠습니다. 싱글태스킹 운영체제 : 특정 시점에서 단 하나의 프로그램만 실행 가능 멀티태스킹 운영체제 : 시분할 기법으로 특정 시점에서 2개 이상의 프로그램을 동시에 실행 가능 그런데, 사실 프로그램은 CPU 만으로 돌아가지 않는다는 건 다 아실 겁니다. 여러 프로그램이 ‘겁나 짧은 단위 시간’마다 전환되기 위해선 실행 중인 프로그램 모두가 RAM에 적재되어 있어야만 CPU가 빠르게 꺼내고 쓸 수 있을 겁니다. 이를 위해선 하나의 메모리 공간을 동시에 돌아가는 프로그램 수만큼 나누고, 나눈 공간에 프로그램을 적재해야 합니다. 이와 같이 하나의 메모리에 ‘여러 개’의 프로그램들을 위한 공간을 만들어, 이 프로그램들을 동시에 메모리에 적재하고 처리하는 시스템을 멀티프로그래밍(다중 프로그래밍, Multi-programming) 시스템이라고 합니다. 결국, 위에서부터 언급한 시분할 기법, 대화형 시스템, 멀티태스킹 (운영체제), 멀티프로그래밍 시스템은 모두 같은 뜻을 향하는 단어임을 알 수 있습니다. 한 대의 컴퓨터에서 여러 프로그램을 동시에 실행시킨다는 공통점을 갖고 있기 때문입니다. 이 기법들은 지금까지도 PC와 서버에서 사용되고 있기 때문에 지금 사용하고 있는 랩톱, 스마트폰에서 뭘 눌렀을 때에 대한 피드백을 즉각적으로 받을 수 있고, 전 세계 사용자가 접속하는 구글의 서버 또한 검색어를 입력하면 그에 따른 결과를 바로 보여줌으로써, 각 사용자는 혼자서 서비스를 누리는 것처럼 느끼게 해줍니다. CPU 작업 시간을 ms 시간 단위로 쪼개면서 까지 한 번에 여러 프로그램을 실행한다는 건, 그 만큼 CPU가 놀 시간을 주지 않겠다는 의미이기도 합니다. 그렇기 때문에 시스템 전반적인 입장에서 CPU의 이용률(Utilization), 처리량(Throughput)이 증가할 겁니다. 위 내용은 모두 싱글 프로세서(Single processor) 시스템 기준으로 다룬 겁니다. 멀티 프로세서(Multi-processor) 시스템은 여러 대의 CPU가 하나의 컴퓨터에 탑재되어 있기 때문에 더 복잡한 구조를 가져야 한다고 합니다. 요청 작업 처리 기법에 따른 분류앞에서 시분할 기법을 적용한 컴퓨터 시스템인 대화형 시스템을 꺼냈었습니다. 현재까지도 수 많은 컴퓨터가 사용하고 있는 방식으로, 특정 작업을 요청한 사용자 입장에서 짧은 응답 시간에 따른 여러 이점을 가져다 주었습니다. 일괄 처리(Batch processing) 기법을 알고 나면 시분할 기법이 가져다 주는 이점이 더 잘 느껴지실 것 같습니다. 일괄 처리 방식은 말 그대로, 한 번 작업을 요청받으면 순차적으로 정해진 프로그램(코드)에 따라 일괄적으로 처리하는 데에만 몰두합니다. 그렇기 때문에 사용자는 요청한 작업에 대한 결과를 얻을 때까지 다른 작업을 할 수 없고, 이는 응답 시간, 반환 시간(Turn around time)이 상대적으로 더 증가함을 의미합니다. 일괄 처리 기법은 초창기 컴퓨터의 천공 카드 시스템에서 사용되었었습니다. 하지만 지금도 효율성을 증대시키기 위해 한꺼번에 데이터를 빠르게 처리해야 하는 분야에서 사용하고 있다고 합니다. 하나의 작업에만 몰두하기 때문에, 컴퓨터 시스템 자원의 유휴 시간이 줄어들고 이용률(Utilization)이 증가하는 이점이 있기 때문입니다. 일괄 처리와 반대되는 시분할 기법의 경우 사용자가 작업을 요청해도, 결과가 나올 때까지 자신이 요청한 작업에만 몰두하지 않을 겁니다. (나중에 알게 될) 라운드 로빈(Round Robin, RR) 스케줄링 알고리즘에 따르면, 프로그램에 정해진 타이머 값에 따라 작업을 다 못 끝내도 다른 프로그램(프로세스)의 작업을 처리하러 가야하기 때문입니다. 사용자 입장에서는 요청한 작업에 대한 반응 속도(Response time)가 상대적으로 느려질 수 있을 겁니다. 미사일을 날리거나 멀티미디어 스트리밍을 처리하는 것과 같이, 작업에 대한 처리 결과를 매 시점마다 늦지 않게 제공받아야 제대로 작동하는 분야에도 컴퓨터 시스템이 존재합니다. 그래서 이러한 분야에서는 **실시간 운영체제(RealTime Operating System, RTOS)**가 필요합니다. 정해진 시간 안에 반드시 작업을 완료하는 능력을 가진 운영체제이기 때문입니다. 특히, 미사일 혹은 비행기 항법을 위한 임베디드 시스템은 조금이라도 처리 시간이 흐트러져, 신뢰성이 낮아지면 아주 위험한 결과를 야기할 수 있습니다. 이렇게 엄격한 분야의 컴퓨터 시스템에는 **경성 실시간 운영체제(Hard RealTime Operation System)**가 탑재됩니다. 하지만 동영상 혹은 음악 스트리밍 처리 시스템과 같이 처리 결과가 전달되는 시간이 조금이라도 흐트러지면 제대로 된 결과(기능)를 제공할 수 없긴 하지만, 그렇다고 해서 지구가 박살나는 정도의 위험한 결과를 야기하지 않는 경우에는 **연성 실시간 운영체제(Soft RealTime Operation System)**를 사용합니다. 사용자가 요청한 작업을 어떠한 기준으로 처리하는지에 따라 운영체제를 아래와 같이 분류하고, 각자의 특징을 정리할 수 있겠습니다. 일괄 처리 기법 : 요청받은 작업만 한 꺼번에 일괄적으로 처리하기에 응답 시간, 반환 시간이 증가하지만 유휴 시간이 줄어들고 이용률이 증가한다. 시분할 기법 : CPU의 작업 시간을 짧은 시간 단위로 나누어, 여러 프로그램으로부터 요청받은 작업을 동시에 처리하기에 응답 시간이 줄어들지만 반응 속도가 증가한다. 실시간 운영체제 : 요청받은 작업을 정해진 시간 내에 반드시 완료됨을 보장한다. 다시 2개로 나누어져, 시간 제약, 미완료 시 파급력에 따라 다른 종류의 실시간 운영체제가 탑재된다. 경성 실시간 운영체제 : 위험한 작업을 다루며 제 시간에 결과를 제공받아야만 제대로 작동할 수 있는 분야에서 사용 연성 실시간 운영체제 : 미완료 시 파급력이 상대적으로 덜하기 때문에, 제대로 된 결과를 제공받지 못해도(결과가 불완전해도) 파급력이 미미한 분야에서 사용 References Operating System Concepts 운영체제와 정보기술의 원리","link":"/2020/11/18/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C/"},{"title":"컴퓨터 시스템의 실행 구조 파트 1 : Computer System Organization Part 1","text":"너무 길어져서 파트로 나누게 됐습니다. 시간날 때마다 글을 다듬는 중인데, 좀 흐름이 꼬이는 느낌이라 갈아엎을 수도 있습니다(…) 컴퓨터 부팅 과정(Startup)컴퓨터(본체)의 전원 버튼을 누르자마자 부트스트랩(Bootstrap)이라는 프로그램이 실행됩니다. 띠용.. 다른 프로그램은 마우스나 키보드로 직접 실행해야 했던 걸 생각하면 의문이 들지 않나요? 부트스트랩이 아무 조작 없이 반사적으로 실행될 수 있는 이유는 하드웨어의 ROM(Read-Only Memory) 혹은 EEPROM(Electrically Erasable Programmable Read-Only Memory)에 펌웨어 형태로 기록되어 있기 때문입니다. 부트스트랩은 CPU 레지스터부터 장치들의 컨트롤러(바로 밑에 나옵니다!)까지 시스템 전반적인 영역을 초기화하는 역할을 가진 프로그램입니다. 초기화가 끝나면, 부트스트랩이 부트 로더(Boot loader)를 실행하면서 퇴장합니다. 부트 로더는 운영체제가 디스크에서 어디에 위치해있는지 무조건 알고 있습니다(여러 개의 운영체제가 설치되어 있는 멀티부팅(Multi-booting) 컴퓨터가 아니라면요). 그리고 어떻게 운영체제를 실행하는지까지 알고 있습니다. 앞 포스트에서 운영체제의 모든 영역이 아닌, 커널만 항상 메모리에 상주해야 한다고 했었습니다. 그래서 부트 로더는 커널을 메모리에 적재한 후 실행시킵니다. 커널이 실행됨으로써 시스템과 사용자에게 서비스를 제공할 수 있게 됐지만, 아직 부팅 과정이 끝나지 않았습니다. 보통 우리가 컴퓨터로 뭘 할 수 있는 단계가 되려면, 커널 외부의 다른 부가적인 서비스 또한 실행되어야 합니다. 바로 시스템 프로세스 init(UNIX의 경우), 시스템 데몬(Daemon)입니다. 이 둘은 커널과 함께 백그라운드(background)에서 실행되어지는데요. 특히 시스템 프로세스의 경우 또 다른, 수 많은 데몬들을 실행시키는 역할을 가지고 있습니다. 이후 시스템이 완전히 부팅된 후에는 사용자에 의해 이벤트가 발생할 때까지 대기합니다. 전반적인 컴퓨터 시스템 구조컴퓨터 시스템에서 어떠한 명령이 이루어질 수 있는 건, CPU가 일을 하고 있기 때문일 겁니다. 그런데 사실 명령을 수행하려면 CPU 외에도 여러 장치 간 유기적인 인터렉션이 있어야만 합니다. 당장 우리가 크롬을 실행하려면 마우스로 아이콘을 딸각 딸각 클릭해야 하죠? 즉, 컴퓨터 시스템 동작은 CPU에 의해서만 이루어질 수는 없습니다. 그래서, CPU가 명령을 수행하기 위해 반드시 필요한 전반적인 장치들을 살펴보고자 합니다. &lt;컴퓨터 시스템을 이루며, 명령을 수행하는 데에 반드시 필요한 장치들의 전반적인 구조를 나타낸 이미지입니다. 중앙에 위치한 초록색의 공통 버스 선을 기준으로 좌측은 컴퓨터 시스템의 내부 장치, 우측은 외부(입출력) 장치에 해당합니다. 키보드의 경우 최근 대부분 USB 포트로 연결하기에, USB 컨트롤러로 대신해도 될 것 같습니다.&gt; 현대의 컴퓨터 시스템은 CPU와 메모리와 같은 내부 장치와 보조 기억 장치(디스크), 키보드, 마우스, 모니터와 같은 외부 장치로 이루어져 있습니다. (사실 실질적으로 내부 장치들이 컴퓨터 시스템을 구성하는 요소에 해당됩니다.) 대부분의 작업을 처리하기 위해 외부 장치에서 내부 장치로 데이터를 전달받고, 내부 장치에서 연산한 결과를 외부 장치로 내보내는 액션이 반복적으로 이루어집니다. 이때 하나의 액션에서 입력이 외부 장치로부터 전달되고, 출력 또한 외부 장치로 전달되기 때문에 외부 장치를 많은 사람들이 입출력(I/O) 장치로 부릅니다. 그래서 저도 앞으로 입출력 장치로 부르려고 합니다. 인터럽트 선은 입출력 장치 등이 CPU에게 작업이 완료됐다는 신호와 같은 인터럽트를 보내기 위해 사용합니다. 인터럽트 또한 컴퓨터 시스템 운영에 중요한 요소이기 때문에, 이후에 자세히 언급됩니다. 우리가 일반적으로 사용하는 프로그램이 실행되기 위해선, 메모리에 프로그램을 구성하는 데이터가 적재된 후 CPU 자원을 사용하기 위한 CPU 제어권을 받아야 합니다. 멀티 프로세서 컴퓨터 시스템과거에는 메인 CPU 단 하나만 탑재된 싱글 프로세서 컴퓨터 시스템을 사용했었습니다. 하지만 최근에는 대부분 멀티 프로세서 컴퓨터 시스템이 사용됩니다. 2개 이상의 프로세서가 탑재되어 아래와 같은 장점이 있기 때문입니다. 높은 처리량(Throughput) : 같은 양의 작업에 대한 더 빠른 연산 속도를 제공합니다. 하지만 프로세서 수 대비 속도(성능)가 비례해서 증가하진 않습니다. 로그 함수 형태의 성능 증감이 발생하기 때문입니다. 팀플 생각해보면… 비용 절감 : 싱글 프로세서 컴퓨터 시스템을 여러 대 구축하는 것보다 저렴합니다. 싱글 프로세서 컴퓨터 시스템을 n 대 구축하려면 프로세서 외에도 주변 장치(Peripherals)까지 n 세트 구축해야 하지만, 멀티 프로세서 컴퓨터 시스템은 주변 장치 한 세트를 서로 공유할 수 있습니다. 하나의 컴퓨터 시스템 안에 여러 프로세서가 존재하기 때문입니다. 장애 허용 시스템(Fault Tolerant) 구축에 따른 높은 신뢰성 : 작업을 여러 프로세서에 분산해 처리하던 중에 프로세서 하나가 고장 등으로 인해 연산을 멈출 가능성이 있을 겁니다. 하지만 여러 개의 프로세서가 존재한다면 이를 극복할 수 있습니다. 멈춘 프로세서는 버리고(…), 남은 다른 프로세서를 이용해 독립적으로 연산할 수 있도록 운영할 수도 있기 때문입니다. 덕분에 컴퓨터 시스템 전체 성능은 저하되더라도 작동은 유지될 수 있습니다. 특히 장애 허용 시스템은 특정 영역에서 고장 등의 상황이 발생해도 성능이 저하되는 대신, 전체 시스템이 계속 작동할 수 있었는데요. 이러한 기법을 우아한 성능 저하(Graceful degradation)이라는 용어로 부르기도 합니다. 즉, 멀티 프로세서 컴퓨터 시스템은 우아한 성능 저하 기법을 통해 신뢰성을 높일 수 있는 겁니다. 여러 프로세서가 존재하는 만큼, 이들을 운영하는 방법 또한 존재하는데요. 이 중, 대칭 멀티프로세싱 기법으로 운영하면 모든 프로세서가 하나의 메모리를 공유하고 하나의 작업을 프로세스들끼리 서로 나누어(병렬적으로) 수행하게 됩니다. 그래서 앞서 설명했듯이 하나의 프로세서가 작동을 멈춰도 남은 프로세서들에게 하던 작업을 다시 나누어줄 수 있게 됩니다. (고장난 프로세서는 이후 혼자서 재부팅합니다.) 비대칭 멀티프로세싱은 계층적인 구조로, 보스(Boss) 프로세서가 전체 시스템을 제어하면서 나머지 프로세서들에게 지시를 내립니다. 모든 프로세서가 공평하게 하나의 일을 분담하던 대칭 멀티프로세싱과 구분되죠? 보스 프로세서가 작동을 멈추면 시스템 전체도 멈출 수밖에 없지만, 다른 프로세서가 보스의 지시를 받고 수행하기에 부하들의 분산(Load Balancing)을 효율적으로 할 수 있기도 합니다. 기술이 발달하면서 최근에는 여러 개의 칩셋을 뭉치는 것보다, 하나의 칩셋 안에 CPU 역할을 하는 코어(Core)를 2개 이상 집접해 멀티 프로세서를 구현하는 편입니다. 여러 개의 칩셋을 뭉치면 각 ‘칩셋(칩)’ 단위로 통신(Between-Chip Communication) 해야 하는데요, 하나의 칩셋 안에 여러 코어를 집접하면 하나의 칩셋 내부에서만 통신(On-Chip Communication) 하면 되기 때문에 비용 측면에서 더 효율적이기 때문입니다. 이렇게 하나의 칩셋 안에 여러 코어를 집접해 멀티프로세서 컴퓨터 시스템을 구현한 것을 멀티코어(Multi-core) 컴퓨터 시스템이라고 부릅니다. 예전에 비해 네트워크는 정말 많이 발전한 분야 중 하나입니다. 이 네트워크를 이용해 여러 대의 컴퓨터를 하나로 모아 보다 고성능의 멀티프로세서 컴퓨터 시스템을 구축할 수도 있는데요, 바로 클러스터 시스템입니다. 하지만 클러스터 시스템은 네트워크를 이용해 서로 ‘다른 위치에 있는 독립된 컴퓨터/노드(node)들을’ 묶어 하나의 시스템을 이루는 약결합(Loosely coupled) 구조때문에 지금까지 설명한 멀티프로세서 컴퓨터 시스템과는 좀 다릅니다. 특히, 네트워크 상태에 따라 컴퓨터 시스템 성능이 좌우될 수 있고, 여러 대의 컴퓨터 자체가 연결되어 있다보니 유지 보수가 힘듭니다. 그럼에도 클러스터 시스템을 사용해 멀티 프로세서 컴퓨터 시스템을 구축하는 이유는 상대적으로 더 저렴하게 가용성 높은(High-Availiability) 서비스를 제공할 수 있기 때문입니다. 마지막으로 클러스터 시스템은 컴퓨터(노드)의 작동 방법에 따라서도 세분화되는데요. 하나의 컴퓨터를 상시 대기 모드(Hot-standby Mode)로 놔두고, 다른 컴퓨터를 모니터링 하는 역할만 부여하는 방법은 비대칭 클러스터링이라고 합니다. 문제가 생기면 모니터링 하던 컴퓨터가 서버 역할을 하게 됩니다. 또한, 하드웨어 자원을 최대로 활용하기 위해서 2개 이상의 컴퓨터가 작업을 수행하면서, 다른 컴퓨터를 모니터링까지하는 대칭 클러스터링도 있습니다. 컴퓨터 시스템 내부 장치CPU는 또 다른 내부 장치인 메모리의 특정한 곳(주소)에 위치한 명령어(Instruction, 기계어)를 하나씩 읽은 후 실행하는 것을 빠른 속도로 반복하는 어떻게 보면 생각한 것보다 단순한 작업을 반복하는 장치입니다. 이때 이 작업 한 번을 하나의 clock cycle로 취급합니다. 즉, CPU는 자신의 매 clock cycle 마다 메모리에서 명령어를 하나 씩 읽은 후 실행하게 되는 겁니다. while이나 if 같은 코드(명령어) 반복이나 분기가 없는 일반적인 경우, 다음 clock cycle에는 직전에 읽었던 메모리의 특정한 곳(주소)의 직후(바로 다음)에 위치한 명령어를 실행함으로써, 코드를 순차적으로 읽게 됩니다. 이를 위해 CPU는 명령어를 읽기 전에 프로그램 카운터(Program Counter)라는 레지스터 저장 장치를 참조하는데요. 이 프로그램 카운터에 CPU가 실행해야 할 명령어의 메모리 상에서의 주소가 저장되어 있기 때문입니다. 메모리는 CPU와 함께 컴퓨터 시스템의 내부 장치로 구성되어, CPU가 실행할 프로그램 관련 데이터를 가지고 있기에 CPU의 작업 공간 역할을 합니다. 위에서 나왔듯이, CPU가 처리해야 할 명령어를 저장하면서도, 처리한 데이터를 저장하기 때문입니다. 일반적으로 디스크와 같은 보조 기억 장치보다 훨씬 빠르지만, 전원이 공급되지 않으면 저장하고 있던 디지털 데이터가 날라가버리는 휘발성 매체를 사용합니다. 가장 대표적인 게 RAM(Random Access Memory)입니다. 전반적인 시스템 구조 이미지 상에서, CPU는 메모리 말고도 각 입출력 장치의 로컬 버퍼에도 접근할 수 있는데요, 로컬 버퍼는 바로 아래에서 자세히 이어집니다. 입출력 장치외부 장치로부터의 데이터가 있어야만 컴퓨터 시스템이 명령을 수행할 수 있는 경우가 있습니다. 이때, 데이터를 주고 받기 위해 필요한 장치들이 좀 있습니다. 디스크와 같이 입력과 출력 모두 가능하거나, 키보드나 모니터와 같이 둘 중 하나만 가능한 장치가 있습니다. 입출력 장치 컨트롤러위에서 읽으셨듯이, CPU가 작업 대부분을 처리하기 위해서는 입출력 장치로부터 ‘데이터’를 받고 내보내는 과정이 이루어져야만 합니다. 즉, 컴퓨터 시스템에서는 CPU에 의해서만 작동하는 게 아니 입출력 장치로부터 데이터를 전달받고, 연산한 결과를 다시 보내주는 과정이 반복됩니다. 하지만… 그렇다고 해서 내부 장치인 CPU가 컴퓨터 시스템 외부에 위치한 여러 입출력 장치까지 돌아다니면서 데이터를 받고 내보내는 과정에 관여하는 건 비용이 너무 큽니다. 특히 CPU 처리 속도와 대부분 입출력 장치의 처리 속도 차이가 엄청나거든요. 그래서 모든 입출력 장치에는 컨트롤러가 가장 선두에 위치해 이들을 제어합니다. 장치에 대한 일종의 자치 기구 역할을 하는 셈입니다. (메모리를 제외한) 입출력 장치는 컴퓨터 시스템 외부에 위치해있기에, 사실 상 컴퓨터와 연결된 별도의 전자 ‘제품’으로도 볼 수 있습니다. 이 관점에서 보자면, 컨트롤러는 입출력 장치의 CPU로 봐도 무방합니다. 그래서 모든 입출력 장치는 이 컨트롤러에 의해 운영됩니다. 디스크의 경우에는 헤더를 어떻게 움직일지, 어떤 섹터의 데이터를 읽을지와 같은 내부 요소가 디스크 컨트롤러에 의해 통제되는 셈입니다. 덕분에, CPU와 컨트롤러 각자는 동시에 독자적인 작업을 수행할 수도 있게 됩니다. 그래서 싱글 프로세스 시스템에서 사용자 프로그램 A가 CPU를 꽉 쥐고 있어 자신의 코드를 실행하면서도, 사용자 프로그램 B에 의해 보조 기억 장치(디스크)에서 데이터를 읽는 것 또한 가능해집니다. 디스크 컨트롤러가 이를 수행하기 때문입니다. 모든 장치들의 컨트롤러는 CPU와 함께 공통 버스 선을 통해 메모리를 공유하는 구조를 가지고 있고, 운영체제의 장치 드라이버에 의해 제어됩니다. 그렇기에, 프로그램 실행 도중에 사용자로부터 입력을 받거나, 디스크와 같은 곳에서 데이터를 읽어야 하는 상황이 발생하면 해당 장치 드라이버를 통해 관련 제어(해당 장치가 해야 할 일) 정보를 해당 장치 컨트롤러에게 전달하게 됩니다. 장치 드라이버는 컨트롤러를 제어하기 위해 운영체제 커널에 내장되어 있는 것으로, CPU가 현재 프로그램을 실행하기 위해 입출력 장치에게 전달해야 할 코드를 가지고 있습니다. 로컬 버퍼모든 입출력 장치는 CPU 역할을 하는 컨트롤러가 존재한다고 했었습니다. 그렇다면, 이들 또한 컴퓨터 시스템처럼 작업 공간 역할을 하는 메모리가 필요할텐데요, 그래서 각 장치 별로 로컬 버퍼(Local buffer)가 존재합니다. 로컬 버퍼는 입출력 장치에서부터 데이터가 발생할 때, CPU로부터 연산 결과 데이터를 받아올 때와 같이 컨트롤러의 입출력 연산 과정에서 이를 임시로 저장하기 위해 사용합니다. 대부분의 입출력 장치의 작업 속도는 CPU보다 아주 느리기 때문에, 둘의 격차를 보완하기 위해서도 사용하고요. 로컬 버퍼에서 일어나는 입출력 연산의 전반적인 과정을 설명하기 위해, 한 애플리케이션이 다음 작업을 하기 위해 필요한 데이터를 디스크에서 읽어와라고 명령하는 상황을 예로 들어보겠습니다. 먼저 읽기 명령을 수행하기 위해 운영체제의 장치 드라이버가 컨트롤러의 레지스터를 로드(Load) 하면, 컨트롤러가 이 레지스터에서 명령을 접수합니다. 컨트롤러는 물리적 디스크에서 내용을 읽은 후 로컬 버퍼에 저장합니다. 애플리케이션이 필요로 하는 데이터가 로컬 버퍼에 모두 읽어들여졌으면(읽기 명령을 모두 수행했다면), 컨트롤러가 인터럽트라는 신호 체계를 통해 CPU에게 이를 알립니다. (위에서 언급했듯이, CPU가 입출력 장치까지 돌아다니면서 데이터를 받고 내보내는 과정에 관여하는 건 비용이 너무 크기 때문에 컨트롤러와 분업하는 겁니다!) 마지막으로 CPU는 로컬 버퍼에서 메모리로 데이터를 이동시킴으로써, 명령 수행을 완료하게 됩니다. DMA원래 메모리는 같은 내부 장치에 속해있는 CPU에 의해서만 접근할 수 있습니다. 그래서 입출력 장치 등에서부터 들어오는 데이터 모두는 (위의 입출력 연산 과정에서 보셨던 것처럼) 인터럽트 체계 때문에 CPU가 관여해야 합니다. 하지만 CPU 혼자서 이 모든 장치들 간 데이터 처리에 관여하다 보니, 컴퓨터 시스템의 효율성이 떨어지게 됩니다. 아래에서 언급하겠지만, 잦은 인터럽트는 많은 오버헤드(overhead)를 발생시켜 결과적으로 CPU의 업무를 아주 많이 방해하는 요소가 되기 때문입니다. 그래서 최소한 메모리 접근과 관련된, 데이터 입출력 연산 처리 만큼은 CPU를 통하지 않고 메모리에 바로 접근할 수 있도록 개선할 필요가 있었고, 이에 따라 고안된 게 DMA(Direct Memory Access) 구조입니다. 표준 DMA 구조 기준으로, 메모리에 직접 접근할 수 있는 능력을 가진 DMA 컨트롤러가 컴퓨터 시스템에 포함됩니다. 그리고 데이터가 CPU를 경유하지 않고 DMA 컨트롤러를 거쳐 메모리로 바로 향하게 됩니다. 덕분에 위에서 작성한 입출력 연산 과정 중 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU가 아닌 DMA 컨트롤러가 대신 하게 되고, CPU의 업무는 줄어듭니다. 모든 데이터를 이동시키면 DMA 컨트롤러가 ‘완료 의미의’ 인터럽트를 발생 시켜주기 때문에, 인터럽트 발생 빈도가 획기적으로 줄어들 겁니다. 4K 영화 파일을 외장 하드에서 옮길 때 매 사이클마다 CPU가 관여한다면.. TMI로, DMA 컨트롤러는 정보를 바이트가 아니라 블록 단위로 읽은 후 메모리로 옮깁니다. 그리고 데이터를 옮길 때 CPU를 관여하는 방식을 PIO(Programmed I/O)라고 부른다고 합니다. 입출력 작업사용자 프로그램(애플리케이션)은 CPU에서 실행 중이더라도, 입출력 장치로부터 데이터를 가져오거나, 입출력 장치에 데이터를 저장하려면 반드시 운영체제를 통해야 합니다. 입출력 장치로 직접 접근할 수 없는 이유는, 이후에 설명할 보안 문제와 관련되어 있기 때문입니다. 앞서, 프로그램이 실행되려면 CPU 제어권을 가져야 한다고 했었습니다. 운영체제도 소프트웨어이기에, 결국 하나의 프로그램입니다. 그래서 실행 중인 애플리케이션이 입출력 작업을 해야하면, 가지고 있던 CPU 제어권을 운영체제에게 넘겨주어야 합니다. 이를 위해 애플리케이션은 시스템 호출(System call)을 반드시 해야 합니다. CPU에게 관련 신호를 포함하는 인터럽트를 발생시킬 수 있기 때문입니다. 인터럽트를 통해 CPU 제어권을 넘겨받은 운영체제(커널)는 해당 장치 드라이버를 통해, 장치 컨트롤러에게 사용자 프로그램이 필요로 하는 데이터를 가져와라는 명령을 내리고, 장치 컨트롤러는 입출력 작업을 진행합니다. 모든 실행 중인 프로그램은 메모리에 적재됩니다. 그리고 입출력 장치의 컨트롤러가 필요로 하는 데이터를 모두 가져왔을 때 컨트롤러가 작업 완료 신호를 포함하는 인터럽트를 CPU에게 보낸다고 했었습니다. CPU가 인터럽트를 받으면, 운영체제에게 CPU 제어권이 넘겨지고, 운영체제는 인터럽트 신호 내용을 확인합니다. 그리고 해당 입출력 장치의 로컬 버퍼에 저장된 데이터를 요청한 애플리케이션이 적재된 메모리 공간에 복사함으로써 입출력 작업이 진행됩니다. 입출력 작업 중일 때, ‘입출력 작업을 요청한 애플리케이션의 다음 명령 수행 여부’에 따라 아래처럼 2가지 구현 방식으로 나누어지고, 컴퓨터 시스템의 상황에 따라 동기성(Synchronization)을 보장해야 할 수도 있습니다. 동기식 입출력애플리케이션이 요청한 입출력 작업이 모두 끝날 때까지 다음 명령을 수행할 수 없는 경우, 즉 애플리케이션이 다른 명령을 수행할 수 있는 시점이 입출력 작업이 완료된 시점과 일치해야 한다는 의미로 동기식(Synchronous) 입출력이라고 합니다. 보통 입출력 장치로부터 읽어온 데이터로 작업을 처리하는 경우에 구현하는 방법입니다. 읽어 온 데이터가 있든지 없든지 상관 없는 작업을 처리하는 경우에는 굳이 이 방식으로 구현할 필요는 없습니다. &lt;애플리케이션이 동기식으로 어떠한 데이터의 입출력을 요청했을 때 계층 별 처리 과정을 나타냅니다.&gt; 위 이미지에서 보시듯이, 입출력 작업이 완료될 때(입출력 요청이 처리될 때)까지 애플리케이션은 계속 기다리는 상태를 유지해야 하기에, 다음 명령을 수행할 수 없는 것과 같습니다. 입출력이 완료됐다는 인터럽트가 발생해야 애플리케이션이 다음 명령을 수행할 수 있기 때문입니다. 그래서 프로그램이 입출력 작업을 요청하면, 인터럽트에 의해 CPU 제어권이 커널의 장치 드라이버로 넘어감과 동시에 운영체제에 의해 입출력 작업이 끝날 때까지 대기하게 됩니다. 그런데, 입출력 작업이 끝날 때까지 CPU가 아무 연산도 하지 않으면 매 시점마다 단 한 번의 입출력 작업만 발생할 수 있게 됩니다. 덕분에… 컴퓨터 시스템 전반적으로 아주 비효율적으로 동작하게 될 겁니다. (특히 입출력 장치는 CPU에 비해 많이 느리다고 했었죠…) 결국 이는 컴퓨터 시스템 입장에서 CPU 혹은 다른 입출력 장치 자원의 낭비로 이어집니다. 이 비효율성을 개선할 수 있는 구현 방법이 있습니다. 기본적으로 동기식 입출력 방식은 ‘현재 실행 중인 프로그램’이 이후의 명령을 수행할 수 없다고 했지, 다른 프로그램이 명령을 수행할 수 없다곤 안 했거든요! 어차피 현재 실행 중인 프로그램인 애플리케이션(A)이 필요한 입출력 데이터가 없어 다음 명령을 수행할 수 없다면, 그냥 다른 애플리케이션(B)이 다른 명령을 수행할 수 있게 함으로써 CPU가 노는(유휴) 시간을 최소화 하는 겁니다. 즉, CPU 제어권을 다른 프로그램에게 넘겨주는 건 가능하다는 이야기입니다. 그리고 B가 자신의 명령을 다 수행해도, CPU 제어권을 또 다른 애플리케이션(C, D, E……..)에게 넘겨줬으면 넘겨줬지 A에게는 절대 넘겨주지 않을 겁니다. CPU 제어권이 있어도, 필요로 하는 입출력 데이터가 없어 다음 명령을 수행할 수가 없기 때문입니다. 그러니까, A가 CPU 제어권을 넘겨 받고 다음 명령을 수행할 수 있는 시점은 요청한 입출력 작업이 모두 다 끝났다는 인터럽트가 발생했을 때 뿐입니다. A처럼, 입출력을 요청했으면서, 입출력 완료 관련 인터럽트가 발생하지 않아 입출력 작업 완료 인터럽트가 발생할 때까지 대기 중인 프로그램을 프로세스 봉쇄(Blocked) 상태가 되었다고 말합니다. 아, 당연히 B는 A처럼 입출력 데이터가 필요한 프로세스 봉쇄 상태가 아니라는 가정 하에 CPU 제어권을 넘겨주는 겁니다! 만약 B도 A와 비슷한 이유로 프로세스 봉쇄 상태라면, 운영체제는 또 다른 애플리케이션에게 CPU 제어권을 넘겨줄 겁니다. TMI로, A가 프로세스 봉쇄 상태에서 풀려나더라도 웬만해선 ‘바로’ CPU 제어권을 가질 수 없을 겁니다. 컴퓨터 시스템에선 수 많은 종류의 프로그램이 실행되어야 하지만 CPU는 1개 뿐이기에 운영체제는 나름의 방법대로 프로그램들을 적절히 줄 세워 차례대로 CPU 제어권을 넘겨줍니다. 그러니까, A가 프로세스 봉쇄 상태에서 풀려나면 이 줄의 맨 뒤에 다시 서서 새치기는 하면 안 되고 자신의 차례가 올 때까지 기다릴 수밖에 없습니다. 이와 관련해 자세한 건 다음 장에서 배우게 됩니다! 입출력 장치 큐바로 위에서 설명한 개선된 동기식 입출력 구현 방법은 CPU의 유휴 시간을 줄일 수 있기 때문에 효율적입니다. 이는 매 시점마다 2개 이상의 입출력 또한 발생할 수 있다는 말입니다. 하지만, 이는 동기성이 보장되지 않아 기대했던 것과 다른 데이터 결과가 발생할 수 있습니다. 원래 1이었던 디스크의 특정 데이터 값을 애플리케이션 A가 3으로 바꾸는 입출력 작업을 요청하면, A는 작업이 완료될 때까지 대기할 겁니다. 그리고 애플리케이션 B에게 CPU 제어권이 넘겨졌다고 생각해봅시다. 그런데, 유감스럽게도 B 또한 A가 바꾸려고 했던 데이터에 접근해, 데이터 값을 기존에서 1 증가시키는 입출력 작업을 요청하는 겁니다. 앞에서 여러 입출력 작업이 동시에 진행될 수 있다고 했었습니다. 문제는, 이 구조 만으로는 해당 장치의 컨트롤러가 A와 B의 입출력 작업 요청 중 어떤 것을 먼저 실행할 지 알 수 없다는 겁니다. A의 요청을 먼저 처리해 데이터 값이 1에서 3으로 바뀌고, 이후 B의 요청을 처리하고 나면 3에서 4가 될 겁니다. 하지만 B의 요청을 먼저 처리하면, 데이터 값이 1에서 2로, 그리고 A의 요청을 처리하고 나면 3이라는 결과가 나올 겁니다. &lt;입출력 장치 중 디스크, 키보드, 프린터의 큐 자료구조를 나타냅니다. 키보드에는 3개의 프로세스가, 프린터에는 1개의 프로세스가 입출력을 요청해 순서대로 기다리고 있는 상황입니다.&gt; 그래서 입출력 장치 큐(디바이스 큐, Device Queue)가 존재합니다. 이 큐는 모든 입출력 장치가 가지고 있는 것으로, 요청 순서대로 입출력 작업을 처리할 수 있게 합니다. 먼저 들어온 요청부터 큐에 enqueue 되기 때문에, 입출력 장치 입장에서는 하나 씩 dequeue하기만 하면 매 시점마다 하나씩 할당받은 입출력 작업을 수행할 수 있습니다. 위 이미지처럼 큐 자료구조를 유지하고 관리하기 위해 입출력 장치 별로 큐 헤더가 존재합니다. 뒤 이어 장치 별로 입출력 작업을 요청한 프로세스들의 정보가 순서대로 enqueue 되어 큐 헤더에 의해 관리됩니다. 비동기식 입출력그런데, 사실 CPU 제어권을 받고 실행 중인 애플리케이션이 CPU로 연산한 결과 데이터를 디스크에 저장하는 작업과 같은 경우에는 입출력 장치에게 데이터를 요청한 후에도 다음 명령을 수행하는 데에 무리가 없을 겁니다. 그래서 보통 위와 같은 상황에서는 입출력 작업을 요청한 애플리케이션의 CPU 제어권을 빼앗지 않고, 다시 돌려주는 비동기식(Asynchronous) 입출력 방식으로 구현합니다. 즉, 비동기식 입출력 방식에서는 요청 입출력 데이터와 관련 없는 명령이어도 요청한 애플리케이션이 곧 바로 수행할 수 있게 됩니다. 물론, 연관된 명령일 경우에는 입출력 작업이 끝난 후에 수행되지만요. 애플리케이션이 비동기식으로 어떠한 데이터의 입출력을 요청했을 때 계층 별 처리 과정을 나타냅니다. 위 이미지에서 보시는 것과 같이, 비동기식 입출력 방식에서도 입출력 작업 완료 신호를 인터럽트로 알려주는 건 동일합니다. 인터럽트처음부터 이 포스트를 차근히 읽어오셨다면 이젠 익숙해질 때가 되셨을 겁니다! 인터럽트는 CPU에게 이벤트를 발생시켜, CPU가 제공하는 서비스가 필요하다는 신호를 보내는 행위를 의미합니다. 포스트의 초반부에서, 입출력 장치들은 자신에게 할당된(요청받은) 입출력 연산에 대해선 자신들이 가지고 있는 컨트롤러 덕분에, CPU와 별개로 동작할 수 있다고 설명했었습니다. 즉, 입출력 장치(컨트롤러)의 입출력 연산과 CPU의 연산은 동시에 진행될 수 있다는 말입니다. 하지만, 입출력 장치도 결국 중앙 정부 격인 CPU 자원을 필요로 합니다. 당장 바로 위에서 설명드린 입출력 연산만 봐도 알 수 있죠. 입출력 연산을 다 마친 입출력 장치 컨트롤러는 CPU에게 입출력 작업이 완료됐다고 알려줘야 자신이 작업한 데이터를 요청한 프로그램이 적재된 메모리 공간에 복사함으로써, 진정한 작업 완료가 이루어지기 때문입니다. 문제는, &lt;컴퓨터 시스템 내부 장치&gt;에서 설명했듯이 CPU는 메모리(에 적재된 프로그램)에서 명령어(Instruction, 기계어)를 하나씩 읽은 후 실행하는 것을 빠른 속도로 반복하는 장치입니다. 프로그램 카운터가 가리키는 곳만 보는 바보 그래서 잠시 CPU가 프로그램 카운터가 가리키는 곳을 못 보게 방해해서, 입출력 장치의 신호를 전달할 수 있는 체계가 필요합니다. 그래서 &lt;전반적인 컴퓨터 시스템 구조&gt;에 포함된 이미지를 보시면, CPU 바로 옆에 인터럽트 선이 연결된 것을 확인할 수 있으실 겁니다. 바로 인터럽트가 CPU에게 직접적으로 전달되는 CPU를 방해할 수 있는 통로의 역할을 합니다. 인터럽트 선이 연결만 돼 있으면 뭐합니까, CPU가 이를 인지할 수 있어야겠죠? 그래서, CPU는 매 clock cycle마다 (하나의 명령을 수행한 후에) 인터럽트 선에 인터럽트라는 신호가 발생했는지 확인합니다. 인터럽트가 발생했다면 해당 인터럽트를 처리한 다음에 다음 명령을 수행합니다. &lt;입출력 작업&gt;에서 인터럽트가 사용자 프로그램(애플리케이션)에 의해, 혹은 입출력 장치 컨트롤러에 의해 발생될 수 있었다는 것 기억하시나요? 이러한 인터럽트를 발생시키려면 우선 인터럽트 선을 set 해야합니다. 선을 set 하는 주체는 하드웨어 혹은 소프트웨어가 될 수 있는데요. 입출력 장치 컨트롤러와 같은 하드웨어에 의해 인터럽트 선이 set 되는 경우 하드웨어 인터럽트가 발생했다고 합니다. 그리고 애플리케이션 등 소프트웨어(프로그램 코드)에 의해 인터럽트 선이 set 되는 경우 소프트웨어 인터럽트가 발생했다고 합니다. 이때, 소프트웨어 인터럽트는 트랩(Trap) 이라는 별도의 용어로 많이 부르고, 트랩을 발생시키는 대표적인 게 예외(Exception), 시스템 호출(System call) 입니다. 내부 인터럽트라고도 불리는 예외는 어떠한 값을 0으로 나누려고 할 때(Division by Zero), 할당되지 않은 메모리 영역을 애플리케이션이 접근할 때와 같은 비정상적인 상황에 발생하는 것으로, 이를 처리하려면 커널 영역의 도움을 받아야 하기에, 인터럽트 선을 set 한 후 운영체제에게 CPU 제어권을 넘겨야 합니다. 시스템 호출은 애플리케이션이 커널 영역 내부의 코드(서비스)를 실행해야 할 때, 운영체제에게 대신 해당 서비스를 요청하기 위해 인터럽트 선을 set 함으로써 운영체제에게 CPU 제어권을 넘기는 것을 의미합니다. 소프트웨어 인터럽트인 예외와 시스템 호출은 모두 커널 영역에서 제공되는 무언가를 사용하기 위해 애플리케이션에서 운영체제로 CPU 제어권을 넘겼는데요. 이렇게 번거로운 과정을 거쳐야 하는 이유가 있습니다. 이후에 또 자세히 나오겠지만, 보안 상의 문제로 인해 애플리케이션 영역에 적재된 프로그램은 절대 메모리의 커널 영역에 직접 접근할 수 없도록 설계되어 있기 때문입니다. 인터럽트 처리인터럽트 주도적(Interrupt driven)인 운영체제는 인터럽트가 발생했을 때 CPU가 대기 상태에서 벗어나 인터럽트를 처리하기 때문입니다. 반면, 폴링(Polling) 방식의 운영체제는 주기적으로 이벤트 발생 여부를 직접 확인해야 합니다. 그래서 현대 운영체제 대부분은 인터럽트 주도적으로 설계됩니다. 컴퓨터 시스템 자원을 덜 낭비하기 때문입니다. 그래서 하드웨어 인터럽트, 소프트웨어 인터럽트(트랩) 가릴 것 없이, 일단 인터럽트라는 게 발생한 순간부터 CPU는 대기 상태에서 벗어나거나, 하던 일을 잠시 멈춘 후 해당 인터럽트를 처리할 방법을 확인해야 합니다. CPU가 해당 인터럽트를 어떻게 처리해야 하는지에 대한 정보를 정보(코드)를 인터럽트 처리 루틴(Interrupt Service Routine) 혹은 인터럽트 핸들러(Interrupt Handler) 라고 합니다. 입출력 작업 관련 신호가 포함된 인터럽트에 대해선 파일 읽기, 쓰기 수행 코드가 해당 인터럽트 처리 루틴에 하드 코딩되어 있겠죠? 인터럽트 처리 루틴은 메모리에 저장되어 있는데요. 문제는 CPU가 이를 찾아가야 하는데, 인터럽트는 1개가 아니라는 겁니다. CPU에게 보내야 할 신호는 다양하기 때문에, 여러 개의 인터럽트가 존재합니다. 그리고 이들에 대응하기 위한 인터럽트 처리 루틴 또한 여러 개 존재합니다. 그래서 CPU는 해당 인터럽트에 대한 인터럽트 벡터(Interrupt Vector) 부터 확인합니다. 인터럽트 별 고유 번호를 부여한 후, 이 고유 번호 별로 인터럽트 처리 루틴의 메모리 상 주소를 저장하고 있기 때문입니다. 즉, 인터럽트 벡터에 의해 고유 번호 n 번이 인터럽트가 발생하면, CPU는 인터럽트 벡터에서 n 번에 대응하는 인터럽트 처리 루틴이 가리키는 주소를 확인합니다. 그리고 해당 주소로 이동해 인터럽트 처리 루틴에 접근하고, 이를 통해 인터럽트 처리를 완료하게 됩니다. 인터럽트 처리를 완료한 CPU는 잠시 멈췄던 일로 되돌아가, 다시 진행하게 됩니다. 이후에 자세히 배우겠지만, 이 순간을 위해 CPU가 인터럽트 벡터를 확인하기 전에 진행 중이던 작업에 대한 정보를 커널 내부에 별도로 PCB(Process Control Block)라는 자료구조 형태로 저장하기 때문에 가능한 일입니다. 멈췄던 일로 되돌아가려면 PCB를 다시 불러와 CPU 상에서 복원하면 되거든요! 운영체제도 결국 하나의 소프트웨어이기에, 컴퓨터 시스템은 특정 시점 기준으로 운영체제와 애플리케이션 중 하나만 실행할 수 있습니다. 그리고 앞서 보았듯이, 컴퓨터 시스템이 부팅을 마치면 사용자 프로그램에 의해 이벤트가 발생할 때까지 대기 상태를 유지함과 동시에 인터럽트가 발생해야 CPU 제어권이 운영체제로 넘어갈 수 있었습니다. 이 말은 즉슨 ‘인터럽트가 발생해야만’ CPU 제어권이 운영체제로 넘어가고, 컴퓨터 시스템에서 운영체제가 실행될 수 있음을 의미합니다. 이 외의 모든 상황에서는 항상 애플리케이션이 실행되고 있다는 말이기도 합니다. 운영체제 운영현대의 운영체제는 CPU가 하나라도, 여러 프로그램이 동시에 컴퓨터 시스템에서 실행될 수 있습니다. 덕분에 CPU의 유휴 시간을 최소화 하고, 효율성을 최대화 할 수 있었습니다. 이렇게, 여러 프로그램을 동시에 실행할 수 있게 하는 멀티프로그래밍(Multiprogramming)과 시분할(Timesharing) 기법은 메모리에 많은 프로그램이 함께 적재되어 있기 때문에 가능한 일이기도 한데요. 하나의 메모리에 여러 프로그램이 적재됨으로써, 운영체제를 포함한 다른 프로그램의 실행을 고의적으로 방해하고, 충돌을 일으킬 수 있는 문제를 발생할 수도 있습니다. 메모리에 운영체제와 애플리케이션 A가 적재되어 있고, A가 CPU 제어권을 가지고 있을 때 실행 중이지 않은 운영체제가 적재된 위치에 임의로 접근해 데이터를 빼오거나, 다른 데이터로 덮어씌우는 일이 발생할 수도 있는 겁니다. 심지어 A가 운영체제를 통해 하드웨어 계층까지 접근해서 임의로 인터럽트를 발생시켜버릴 수도 있습니다. 이중 모드그래서 운영체제는 위와 같이 애플리케이션(사용자 프로그램)에 의한 오류 발생을 방지하기 위해 이중 모드(Dual-mode) 기법을 사용합니다. 운영체제는 보통 커널 모드(시스템 모드), 사용자 모드로 나누어져 동작하게 설계됩니다. 위의 애플리케이션 A 처럼, 운영체제를 포함한 다른 프로그램이 적재된 메모리 영역에 접근하는 것과 같이 보안 위험을 야기시킬 수 있는 연산에 대해서는 반드시 커널 모드에서만 실행될 수 있게 제한하기 위해서입니다. 그래서, 기본적으로 커널 모드에서는 운영체제가 커널을 포함한 자신의 코드를 실행할 수 있습니다. 즉, 모든 종류의 연산을 실행할 수 있는 모드입니다. 그리고 사용자 모드에서는 운영체제를 제외한 다른 사용자 프로그램(애플리케이션)은 일반적인, 보안 위험이 없는 연산만 수행할 수 있게 됩니다. 그런데 앞서 말했듯이 운영체제 또한 소프트웨어이기 때문에, 애플리케이션이 CPU 제어권을 가지고 있을 때에는 애플리케이션이 운영체제가 적재된 곳에 접근하는 것을 막을 수가 없게 됩니다. 그래서, 이중 모드의 완벽한 구현을 위해선 모드 비트(mode bit) 라는 별도의 하드웨어가 필요합니다. 모드 비트는 CPU 내부에서 물리적으로 현재 운영체제가 어떤 모드인지 set 할 수 있는 하드웨어인데요. 기본적으로 모드 비트가 0이면 커널 모드, 1이면 사용자 모드로 운영체제의 현재 모드를 표현합니다. 그리고 운영체제가 CPU 제어권을 갖고 있다가 애플리케이션에게 넘겨줄 때에는 모드 비트를 1로 변경해 운영체제를 사용자 모드로 전환하고, 애플리케이션이 운영체제에게 CPU를 넘겨줄 때에는 모드 비트를 0으로 변경해 커널 모드로 전환하도록 설계됩니다. CPU는 운영체제 영역과 애플리케이션 영역을 왔다 갔다할 때 반드시 모드 비트를 확인하도록 설계되어 있기 때문에, 사용자 모드의 애플리케이션이 운영체제 영역에 접근을 시도해도 CPU가 해당 명령을 수행하지 않게 됩니다. 문제는 운영체제가 제공하는 서비스는 결국 운영체제가 메모리 공간에 적재된 곳에서 제공된다는 건데요. 이렇게 모드가 물리적으로 나누어졌을 때에는 애플리케이션이 서비스를 제공받기 위해 운영체제 영역에 어떻게 접근해야 할까요? 당장 위에서 배운 입출력 장치로의 입출력 요청 명령부터 커널 모드에서만 실행할 수 있거든요… 시스템 호출그래서 사용하는 게 시스템 호출입니다. 앞서 한 번 간단히 소개드렸는데요. 시스템 호출은 애플리케이션이 커널 모드에서만 실행 가능한 코드(운영체제가 제공하는 서비스)를 실행해야 할 때, 운영체제에게 대신 해당 서비스를 요청하기 위해 인터럽트 선을 set 함으로써 운영체제에게 CPU 제어권을 넘기는 것을 의미합니다. 인터럽트 선을 set 하는 이유는, 인터럽트가 발생하면 모드 비트가 자동으로 0으로 세팅되어 운영체제가 커널 모드로 전환되기 때문입니다. 물론, 요청받은 작업을 모두 처리한 운영체제는 다시 사용자 모드로 전환한 후 CPU 제어권을 넘겨주게 되고요. References Operating System Concepts 운영체제와 정보기술의 원리","link":"/2020/11/18/%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5-%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B4-%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3-1/"}],"tags":[{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"운영체제","slug":"운영체제","link":"/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}],"categories":[{"name":"프로그래밍 언어","slug":"프로그래밍-언어","link":"/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4/"},{"name":"Swift","slug":"프로그래밍-언어/Swift","link":"/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4/Swift/"},{"name":"기본 문법 정리","slug":"프로그래밍-언어/Swift/기본-문법-정리","link":"/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4/Swift/%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"운영체제","slug":"Computer-Science/운영체제","link":"/categories/Computer-Science/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"}]}